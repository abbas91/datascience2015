set.seed(10)
data = diamonds[sample(nrow(diamonds), 100),]
names(diamonds)
qplot(carat, price, data = diamonds)
qplot(log(carat), log(price), data = diamonds)
install.packages("nlme")
qplot(carat, price, data = diamonds)
?sample
?runif()
m = runif(100,1,2)
num = sample(1:5, m, replace=T)
num
m
data
a = c(1,2,3,4,5,6,7)
?dplyr
?force
install.packages("XML")
library(XML)
theurl <- "file:///C:/Users/mark.li/Desktop/Turbine%20History.html"
tables <- readHTMLTable(theurl)
table.data <- unlist(tables)
tables[[1]]
?rep
rep(2,10,1)
rep(2,10)
rep(2,10, each = 1)
rep(c(2,3,4),10, each = 2)
TP1 <- c(rep(c(3,6,8),100,2))
TP1
TP1 <- rep(c(3,6,8),100,2)
TP1 <- rep(c(3,6,8),100,each = 2)
Tp2 <- rep(c(5,9,1),100,each = 2)
Tp3 <- rep(c(5,2,4),100,each = 2)
Tp4 <- rep(c(3,1,8),100,each = 2)
TP1 <- rep(c(0,6,8),100,each = 2)
Tp2 <- rep(c(5,0,1),100,each = 2)
Tp3 <- rep(c(0,2,4),100,each = 2)
Tp4 <- rep(c(3,0,8),100,each = 2)
Tp1 <- rep(c(0,6,8),100,each = 2)
rm(TP1)
Tp1-Tp2 <- ifelse(Tp1=0,0,1) * ifelse(Tp2=0,0,1)
?ifelse
ifelse(Tp2 = 0,0,1)
ifelse(Tp2 == 0,0,1)
Tp1-Tp2 <- ifelse(Tp1 == 0,0,1) * ifelse(Tp2 == 0,0,1)
Tp1.Tp2 <- ifelse(Tp1 == 0,0,1) * ifelse(Tp2 == 0,0,1)
Tp1.Tp2 <- ifelse(Tp1 == 0,0,1) * ifelse(Tp2 == 0,0,1)
Tp3.Tp2 <- ifelse(Tp3 == 0,0,1) * ifelse(Tp2 == 0,0,1)
Tp4.Tp2 <- ifelse(Tp4 == 0,0,1) * ifelse(Tp2 == 0,0,1)
Tp3.Tp4 <- ifelse(Tp3 == 0,0,1) * ifelse(Tp4 == 0,0,1)
Tp1.Tp4 <- ifelse(Tp1 == 0,0,1) * ifelse(Tp4 == 0,0,1)
x <- runif(1000, -5, 5)
y <- x + rnorm(1000) + 3
x2 <-req(1,1000)
x2 <-seq(1,1000)
x <- as.matrix(cbind(x2,x))
View(x)
x2 <-seq(1,1000,each = 0)
x2 <-seq(1,each = 1000)
?seq
x2 <-rep(1,1000)
x <- as.matrix(cbind(x2,x))
View(x)
rm(x)
x <- as.matrix(cbind(x2,x))
x <- runif(1000, -5, 5)
x <- as.matrix(cbind(x2,x))
View(x)
normal.equaltion <- function (x,y) {
theta <- (solve(t(x)%*%x))
%*%
(t(x)%*%y)
y.predict = t(theta)%*%x
x.list <- list(theta, y.predict)
return (x.list)
}
theta <- matrix()
normal.equaltion <- function (x,y) {
theta <- matrix()
y.predict <- matrix()
theta <- (solve(t(x)%*%x))
%*%
(t(x)%*%y)
y.predict = t(theta)%*%x
x.list <- list(theta, y.predict)
return (x.list)
}
?matrix
normal.equaltion <- function (x,y) {
theta <- vector()
y.predict <- vector()
theta <- (solve(t(x)%*%x))
%*%
(t(x)%*%y)
y.predict = t(theta)%*%x
x.list <- list(theta, y.predict)
return (x.list)
}
y <- as.matrix(x + rnorm(1000) + 3)
normal.equaltion <- function (x,y) {
theta <- vector()
y.predict <- vector()
theta <- (solve(t(x)%*%x))
%*%
(t(x)%*%y)
y.predict = t(theta)%*%x
x.list <- list(theta, y.predict)
return (x.list)
}
solve(t(x)%*%x)
t(x)%*%y
solve(t(x)%*%x)
%*%
(t(x)%*%y)
solve(t(x)%*%x)%*%(t(x)%*%y)
t(theta)%*%x
as.matrix(t(theta))%*%x
solve(t(x)%*%x)%*%(t(x)%*%y)
solve(t(x)%*%x)%*%t(x)%*%y
solve(t(x) %*% x) %*% (t(x)%*%y)
solve(t(x) %*% x) %*% (t(x) %*% y)
y <- (x + rnorm(1000) + 3)
View(y)
x <- runif(1000, -5, 5)
x2 <- rep(1,1000)
x <- as.matrix(cbind(x2,x))
y <- (x + rnorm(1000) + 3)
x <- runif(1000, -5, 5)
x2 <- rep(1,1000)
x1 <- as.matrix(cbind(x2,x))
y <- (x + rnorm(1000) + 3)
solve(t(x1) %*% x1) %*% (t(x1) %*% y)
t(theta)%*%1x
theta <- solve(t(x1) %*% x1) %*% (t(x1) %*% y)
y.predict = t(theta) %*% 1x
predict = t(theta) %*% 1x
predict <- t(theta) %*% 1x
predict <- t(theta) %*% x1
theta <- as.matrix(solve(t(x1) %*% x1) %*% (t(x1) %*% y))
predict <- t(theta) %*% x1
View(theta)
t(theta)
View(`x1`)
x1 %*% theta
predict <- x1 %*% theta
v <- lm(y~x1)
v$coefficients
theta
x <- runif(1000, -5, 5)
x2 <- rep(1,1000)
x1 <- as.matrix(cbind(x2,x))
y <- (x + rnorm(1000) + 3)
normal.equaltion <- function (x,y) {
theta <- vector()
y.predict <- vector()
theta <- as.matrix(solve(t(x1) %*% x1) %*% (t(x1) %*% y))
predict <- x1 %*% theta
x.list <- list(theta, predict)
return (x.list)
}
x <- runif(1000, -5, 5)
x2 <- rep(1,1000)
x1 <- as.matrix(cbind(x2,x))
y <- (x + rnorm(1000) + 3)
normal.equaltion(x1,y)
normal.equaltion <- function (x,y) {
theta <- vector()
y.predict <- vector()
theta <- as.matrix(solve(t(x1) %*% x1) %*% (t(x1) %*% y))
predict <- x1 %*% theta
x.list <- list(theta, predict)
}
x <- runif(1000, -5, 5)
x2 <- rep(1,1000)
x1 <- as.matrix(cbind(x2,x))
y <- (x + rnorm(1000) + 3)
a <- normal.equaltion(x1,y)
a$theta
a$x.list
normal.equaltion <- function (x,y) {
theta <- vector()
y.predict <- vector()
theta <- as.matrix(solve(t(x1) %*% x1) %*% (t(x1) %*% y))
predict <- x1 %*% theta
x.list <- list(theta, predict)
return (x.list)
}
a <- normal.equaltion(x1,y)
a$x.list[[1]]
normal.equaltion(x1,y)
a$x.list
a <- normal.equaltion(x1,y)
a
class(a)
a[[1]]
?double
double(10)
double(5)
cost <- function (x,y,theta) {
sum(y %*% log((exp(x %*% theta)) / (1 + exp(x %*% theta)))
+ (1 - y) %*% log(1 - ((exp(x %*% theta)) / (1 + exp(x %*% theta)))))
* -(1/length(y))
}
cost <- function (x,y,theta) {
sum(y %*% log((exp(x %*% theta)) / (1 + exp(x %*% theta)))
+ (1 - y) %*% log(1 - ((exp(x %*% theta)) / (1 + exp(x %*% theta)))))
* (-(1/length(y)))
}
cost <- function (x,y,theta) {
sum(y %*% log((exp(x %*% theta)) / (1 + exp(x %*% theta)))
+ (1 - y) %*% log(1 - ((exp(x %*% theta)) / (1 + exp(x %*% theta)))))
* (-(1/length(y)))
}
cost <- function (x,y,theta) {
sum(y %*% log((exp(x %*% theta)) / (1 + exp(x %*% theta)))
+ (1 - y) %*% log(1 - ((exp(x %*% theta)) / (1 + exp(x %*% theta))))) * (-(1/length(y)))
}
?glm()
a <- 1:10
a
a <- 1L
a
class(a)
a <- c(1L,2L)
class(a)
a <- as.matrix(a)
class(a)
a
a <- as.vector(a)
class(a)
a <- as.numeric(a)
class(a)
a
sttributes(a)
attributes(a)
a <- as.matrix(a)
attributes(a)
?unclass
?readLine
?readLines
?source
y <- data.frame(a = 1, b = "a")
dput(y)
?dput
a <- dput(y)
a
y
?dump
?dput
?dump
y <- data.frame(a = 1, b = "a")
dput(y, file = "y.R")
rm(y)
y
source("y.R")
y
add <- c(1,2,3,4,4)
sdd <- c(3,4,5,6,7)
s <- data.frame(cbind(add,sdd))
s$a
s["a"]
s["a", exact = F]
s$d
s$s
add * sdd
add %*% sdd
warning(paste0("Seat: ", seat_id, " exported completely."))
seat_id <- 1662
warning(paste0("Seat: ", seat_id, " exported completely."))
install.packages('devtools')
library(devtools)
devtools::install_github('rstudio/rsconnect')
sessionInfo()
library(shinyapps)
object.size(z)
a <- c(1,2,3,4,5)
b <- c(2,3,4,5,6)
z <- cbind(a, b)
object.size(z)
install.packages("Matrix")
library(Matrix)
Z <- Matrix(z, sparse = TRUE)
object.size(Z)
a <- c(1,2,3,4,5)
b <- c(0,0,0,0,0)
z <- cbind(a, b)
object.size(z)
Z <- Matrix(z, sparse = TRUE)
object.size(Z)
z <- as.matrix(cbind(a, b))
object.size(z)
Z <- Matrix(z, sparse = TRUE)
object.size(Z)
m1 <- matrix(0, nrow = 1000, ncol = 1000)
m2 <- Matrix(0, nrow = 1000, ncol = 1000, sparse = TRUE)
object.size(m1)
object.size(m2)
View(m1)
memory.size(max = T)
# Create the loss function
loss <- function(intercept, slope, x, y) sum(((intercept + (slope * x)) - y)^2)/2
# Gradient descent function
grad <- function(x, y, theta) {
gradient <- (t(x) %*% ((x %*% t(theta)) - y))
return(t(gradient))
}
# Show the path of a gradient descent parameter optimization
gradient.path <- function(x) {
# Initialize the parameters
theta <- matrix(c(0, 0), nrow=1)
# Look at the values over each iteration
theta.path <- matrix(ncol=2)
for (i in 1:500) {
theta <- theta - alpha * 1/m * grad(x, y, theta)
if(all(is.na(theta))) break
theta.path <- rbind(theta.path, theta)
}
theta.path
}
install.packages("datasets")
install.packages("datasets")
install.packages("datasets")
library(parallel)
detectCores(all.tests = FALSE, logical = T)
detectCores(all.tests = FALSE, logical = F)
detectCores(all.tests = T, logical = F)
detectCores(all.tests = F, logical = F)
?doMC
install.packages("doMC")
library(doMC)
library(doMC)
library(doMC)
install.packages("doMC")
install.packages("doParallel")
library(doParallel)
library(plyr)
library(parallel)
library(doParallel)
?doParallel
install.packages("doSNOW")
library(doSNOW)
install.packages("doSMP")
library(doSMP)
install.packages("C:/Users/mark.li/Desktop/Code Books/doSMP_1.0-1.tar.gz", repos = NULL, type = "source")
install.packages("revoIPC")
install.packages("revoIPC")
install.packages("C:/Users/mark.li/Desktop/Code Books/revoIPC_1.0-3.tar.gz", repos = NULL, type = "source")
library(Matrix)
install.packages("C:/Users/mark.li/Desktop/Code Books/revoIPC_1.0-3.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/mark.li/Desktop/Code Books/doSMP_1.0-1.tar.gz", repos = NULL, type = "source")
library(revoIPC)
install.packages("C:/Users/mark.li/Desktop/Code Books/doSMP_1.0-1.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/mark.li/Desktop/Code Books/revoIPC_1.0-3.tar.gz", repos = NULL, type = "source")
install.packages("foreach")
library(foreach)
library(parallel)
?parApply
library(parallel)
cat("CPU")
?gl
install.packages("rbenchmark")
library(rbenchmark)
?seq
benchmark(
runif(0,1,100)
seq(1,100,1)
)
benchmark(
runif(0,1,100),
seq(1,100,1)
)
benchmark(
runif(0,1,10000),
seq(1,10000,1)
)
benchmark(
runif(0,1,1000000),
seq(1,1000000,1)
)
sys.time(runif(0,1,1000000))
?sys.time
Sys.time(runif(0,1,1000000))
system.time(runif(0,1,1000000))
system.time(seq(1,1000000,1))
?foreach
?foreach
?foreach
?foreach
?parApply
library(foreach)
?foreach
?select
?select
library(dplyr)
?select
library(plyr)
library(plyr)
library(dplyr)
?ddply
quit()
# shiny server
library(shiny)
#install.packages("DBI")
library(DBI)
#install.packages("RMySQL")
library(RMySQL)
#install.packages("dplyr")
library(dplyr)
# install.packages("muStat")
library(muStat)
percent <- function(x, digits = 2, format = "f", ...) {
paste0(formatC(100 * x, format = format, digits = digits, ...), "%")
}
pretty.number <- function(x, big.mark=",", scientific=FALSE, ...) {
prettyNum(x, big.mark = big.mark,scientific = scientific)
}
format.money  <- function(x, ...) {
paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
# Connect MySQL
# Connect MySQL
mydb <- dbConnect(MySQL(),
user='mark2015',
password='fghfgh67743185',
dbname='mysql_copilot_dash_1',
host='mysql-copilot-dash-instance1.cmzj9dljhdnd.us-east-1.rds.amazonaws.com')
# Create Data Set (table) - All
data_sql.all <- dbSendQuery(mydb, "select Seat_ID, insertion_order_name, line_item_name, line_item_id,
lineitem_Type, date(hour) as Date1,
sum(imps) as IMPs,
sum(clicks) as CLICKs, IFNULL(sum(clicks) / sum(imps),0) as CTR,
sum(total_convs) as TOT_CONVs,
sum(cost) as COST,
sum(revenue) as REV,
sum(profit) as PRFT,
IFNULL(sum(cost) / sum(imps),0) * 1000 as CPM,
IFNULL(sum(cost) / sum(clicks),0) as CPC,
IFNULL(sum(cost) / sum(total_convs),0) as CPA
from copilot_dash_log
group by Seat_ID, insertion_order_name, lineitem_Type, date(hour), line_item_name, line_item_id
order by Seat_ID, lineitem_Type, Date1"
)
data_sql.all <- fetch(data_sql.all, n=-1)
# Quick format on two IDs
data_sql.all$Seat_ID <- as.character(data_sql.all$Seat_ID)
data_sql.all$line_item_id <- as.character(data_sql.all$line_item_id)
IO_List <- unique(data_sql.all$insertion_order_name[data_sql.all$IO_Type = 'Copilot_IO'])
IO_List <- unique(data_sql.all$insertion_order_name[data_sql.all$IO_Type == 'Copilot_IO'])
IO_List
data_sql.all$insertion_order_name[data_sql.all$IO_Type == 'Copilot_IO']
data_sql.all$insertion_order_name[data_sql.all$IO_Type='Copilot_IO']
runApp("copilot_R")
library(shiny)
setwd("C://My desktop files//Code Books//datascience2015//R code//shiny app folder")
runApp("copilot_R")
# shiny server
library(shiny)
#install.packages("DBI")
library(DBI)
#install.packages("RMySQL")
library(RMySQL)
#install.packages("dplyr")
library(dplyr)
# install.packages("muStat")
library(muStat)
percent <- function(x, digits = 2, format = "f", ...) {
paste0(formatC(100 * x, format = format, digits = digits, ...), "%")
}
pretty.number <- function(x, big.mark=",", scientific=FALSE, ...) {
prettyNum(x, big.mark = big.mark,scientific = scientific)
}
format.money  <- function(x, ...) {
paste0("$", formatC(as.numeric(x), format="f", digits=2, big.mark=","))
}
# Connect MySQL
mydb <- dbConnect(MySQL(),
user='mark2015',
password='fghfgh67743185',
dbname='mysql_copilot_dash_1',
host='mysql-copilot-dash-instance1.cmzj9dljhdnd.us-east-1.rds.amazonaws.com')
# Create Data Set (table) - All
data_sql.all <- dbSendQuery(mydb, "select Seat_ID, insertion_order_name, line_item_name, line_item_id,
IO_Type, lineitem_Type, date(hour) as Date1,
sum(imps) as IMPs,
sum(clicks) as CLICKs, IFNULL(sum(clicks) / sum(imps),0) as CTR,
sum(total_convs) as TOT_CONVs,
sum(cost) as COST,
sum(revenue) as REV,
sum(profit) as PRFT,
IFNULL(sum(cost) / sum(imps),0) * 1000 as CPM,
IFNULL(sum(cost) / sum(clicks),0) as CPC,
IFNULL(sum(cost) / sum(total_convs),0) as CPA
from copilot_dash_log
group by Seat_ID, insertion_order_name, lineitem_Type, date(hour), line_item_name, line_item_id
order by Seat_ID, lineitem_Type, Date1"
)
data_sql.all <- fetch(data_sql.all, n=-1)
# Quick format on two IDs
data_sql.all$Seat_ID <- as.character(data_sql.all$Seat_ID)
data_sql.all$line_item_id <- as.character(data_sql.all$line_item_id)
IO_List <- unique(data_sql.all$insertion_order_name[data_sql.all$IO_Type='Copilot_IO'])
data_sql.all$insertion_order_name[data_sql.all$IO_Type='Copilot_IO']
View(data_sql.all)
IO_List <- unique(data_sql.all$insertion_order_name[data_sql.all$IO_Type =='Copilot_IO'])
IO_List
library(shiny)
setwd("C://My desktop files//Code Books//datascience2015//R code//shiny app folder")
runApp("copilot_R")
library(shiny)
setwd("C://My desktop files//Code Books//datascience2015//R code//shiny app folder")
runApp("copilot_R")
